### 排序算法
![](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)
#### 1、冒泡排序

##### 时间复杂度
* 如果数据正序，只需走一趟即可完成排序，所需比较次数C和记录移动次数M均达到最小值，即：Cmin = n - 1、Mmin = 0。所以冒泡排序最好的时间复杂度是O(n)。

* 如果数据反序，则需要进行n - 1趟排序。每趟排序要进行n - i次比较(1 <= i <= n - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
![](https://images2015.cnblogs.com/blog/942621/201604/942621-20160422211518757-642629868.jpg)

    综上：冒泡排序总的时间复杂度为O(n^2)。
    
#### 2、选择排序

选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
综上，简单排序的时间复杂度为 O(n^2)。

#### 3、插入排序
插入排序的时间复杂度分析。在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + ... + (N - 1)，等差数列求和，结果为 N^2 / 2，所以最坏情况下的复杂度为 O(N^2)。
最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(N)。
综上，插入排序的时间复杂度为O(n^2)。

#### 4、希尔排序
希尔排序是插入排序的升级版。
![](https://img-blog.csdn.net/20131004222122953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2lubm9zeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)