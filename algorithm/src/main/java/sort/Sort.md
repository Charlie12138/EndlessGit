### 排序算法
![](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)
#### 1、冒泡排序

##### 时间复杂度
* 如果数据正序，只需走一趟即可完成排序，所需比较次数C和记录移动次数M均达到最小值，即：Cmin = n - 1、Mmin = 0。所以冒泡排序最好的时间复杂度是O(n)。

* 如果数据反序，则需要进行n - 1趟排序。每趟排序要进行n - i次比较(1 <= i <= n - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
![](https://images2015.cnblogs.com/blog/942621/201604/942621-20160422211518757-642629868.jpg)

    综上：冒泡排序总的时间复杂度为O(n^2)。
    
#### 2、选择排序

选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
综上，简单排序的时间复杂度为 O(n^2)。

#### 3、插入排序
插入排序的时间复杂度分析。在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + ... + (N - 1)，等差数列求和，结果为 N^2 / 2，所以最坏情况下的复杂度为 O(N^2)。
最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(N)。
综上，插入排序的时间复杂度为O(n^2)。

#### 4、希尔排序
希尔排序是插入排序的升级版。
![](https://img-blog.csdn.net/20131004222122953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2lubm9zeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

#### 5、归并排序
归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

#### 6、快速排序
关于为什么要从右边开始：
```
while(arr[j]>=temp&&i<j){
    j--;
}
while(arr[i]<=temp&&i<j){
    i++;
}
```
这里两个while的顺序是不能改变的，想一想：
假设对如下进行排序：
![](http://images0.cnblogs.com/blog/751746/201507/171952161265077.jpg)

如上图，6在左，9在右  我们将6作为基数。
假设从左边开始（与正确程序正好相反）
于是i 就会移动到现在的 数字 7 那个位置停下来，而  j 原来在 数字 9 那个位置 ，因为
while(arr[j]>=temp&&i<j)
于是，j 也会停留在数字7 那个位置，于是问题来了。当你最后交换基数6与7时，不对呀！！。
问题在于当我们先从在边开始时，那么 i 所停留的那个位置肯定是大于基数6的，而在上述例子中，为了满足 i<j 于是 j也停留在7的位置
但最后交换回去的时候，7就到了左边，不行，因为我们原本 交换后数字6在边应该是全部小于6，右边全部大于6.但现在不行了。
于是，我们必须从右边开始，也就是从基数的对面开始。